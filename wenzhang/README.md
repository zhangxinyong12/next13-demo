# 浅尝next13
[官网地址](https://nextjs.org/)   
不要看那个所谓的中文网站
## 创建项目
```
npx create-next-app@latest
```
下一步下一步就好了 如图所示
![](./img/1.png)
进到项目目录
```bash
npm run dev
```
打开浏览器访问 http://localhost:3000/ 就可以看到页面了
## 项目结构
![](./img/2.png)
- app目录 next13使用app目录，以前的pages目录也可以使用，但是不推荐使用了。默认使用app，我们接下来的例子都是使用app目录，注意他俩的api是不一样的。
- page.tsx 路由文件 可以认为是默认路由
- layout.tsx 布局文件 引入了globals.css 全局样式文件
## 路由
app目录下面的page.tsx就是路由文件  
我们尝试修改一个app/page.tsx文件
```tsx
export default function Home() {
  return <div>666</div>
}
```
然后刷新页面，就可以看到页面变成了666
![](./img/3.png)
样式太难看了，我们把globals.css里面的样式去掉 
修改一下启动端口
```json
 "scripts": {
    "dev": "next dev -p 3012",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
```
![](./img/4.png)
接下来我们要做一个导航栏，点击导航栏可以跳转到其他页面，再首页还得送上接口数据，我们先来做导航栏
app/components/header
```tsx
import Link from "next/link"
import styles from "./index.module.scss"
export default function Hader() {
  return (
    <div className={`flex justify-center gap-10 ${styles.header} `}>
      <Link className="flex-4" href="/">
        首页
      </Link>
      <Link className="flex-4" href="/about">
        关于
      </Link>
      <Link className="flex-4" href="/list">
        列表
      </Link>
    </div>
  )
}
```
导航组件Link，最后渲染成a标签，href是跳转的地址。
/components/header/index.module.scss
```scss
.header {
  height: 36px;
  > a {
    background-color: #909090;
    padding: 10px 20px;
    display: block;

    height: 100%;
  }
}

```
next里面使用样式文件和react里面一样，看个人喜好，我这里
使用了tailwindcss和scss。
需要安装依赖
```bash
npm install sass sass-loader -D
```
添加ts类型文件
typings.d.ts
```ts
declare module '*.css';
declare module '*.scss';
declare module '*.sass';
declare module '*.svg';
declare module '*.png';
declare module '*.jpg';
declare module '*.jpeg';
declare module '*.gif';
declare module '*.bmp';
declare module '*.tiff';
declare module 'omit.js';

```
tsconfig.json 添加
```json
 "include": [
    ...
    "**/*.d.ts"
  ],
```

注意：如果你把组件放到app目录下并且是page.tsx默认就是路由  
layout.tsx
```tsx
import "./globals.css"
import type { Metadata } from "next"
import { Inter } from "next/font/google"
import Hader from "../components/header"
const inter = Inter({ subsets: ["latin"] })

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <Hader></Hader>
        {children}
      </body>
    </html>
  )
}
```
我们再app目录下分别创建出来对应的页面，记住是 <strong>page.tsx</strong>
![](./img/5.png)
![](./img/6.png)
如图，导航没问题了，接下来我们要做的是接口数据。
## 接口数据 
next13 使用fetch来获取数据，返回一个promise，我们先来看看、
假设现在有个接口地址 http://124.71.160.218:3008/tangshi
- 封装一下fetch
具体看个人喜好和具体业务逻辑，我这里是封装了一下fetch

```ts
// 封装 HTTP 请求函数
export const BaseUrl = process.env.BASE_URL
export class HTTP {
  // 响应拦截器
  static responseInterceptors = (res: any) => {
    if (res.status === 200) {
      return res.data
    } else {
      return Promise.reject(res.message)
    }
  }

  static get(url: string, data?: any, next?: any, cache?: RequestCache) {
    let params = ""
    if (data) {
      Object.keys(data).forEach((key) => {
        params += `${key}=${data[key]}&`
      })
      params = params.slice(0, -1)
      url = `${url}?${params}`
    }
    return fetch(BaseUrl + url, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
      },
      next,
      cache,
    })
      .then((res) => res.json())
      .then((res) => {
        return this.responseInterceptors(res)
      })
  }
  static post(url: string, data?: any, next?: any, cache?: RequestCache) {
    console.log(BaseUrl + url)
    return fetch(BaseUrl + url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(data || {}),
      next,
      cache,
    })
      .then((res) => res.json())
      .then((res) => {
        return this.responseInterceptors(res)
      })
  }
}
```

- api接口
```ts
import { HTTP } from "./http"

enum apiList {
  tangshi = "/tangshi",
}

export async function getTangshiList(params = {}) {
  return HTTP.post(apiList.tangshi, params)
}

// 根据id获取详情
export async function getTestDetail(id: string) {
  const { data } = await HTTP.get(`${apiList.tangshi}/${id}`)
  return data
}
```
- next.config.js
我们区分了一下配置环境，开发环境和生产环境，接口地址不一样
```js
/** @type {import('next').NextConfig} */

// 获取环境变量
const NODE_ENV = process.env.NODE_ENV
const BASE_URL = {
  development: "http://124.71.160.218:3008",
  production: "http://124.71.160.218:3008",
}
const nextConfig = {
  env: {
    BASE_URL: BASE_URL[NODE_ENV],
  },
}

module.exports = nextConfig
```
- app.tsx
```tsx
import { getTangshiList } from "@/http/api"
import Link from "next/link"

export default async function page() {
  const { items }: any = await getTangshiList({})

  return (
    <div className="text-center mt-2">
      <h1 className="text-[20px]">唐诗三百首</h1>
      <div className="flex flex-wrap p-2 mt-4">
        {items.map((item: any) => {
          return (
            <div
              key={item.id}
              className="w-1/6 border text-center hover:bg-gray-200"
            >
              <Link href={`/tangshi/${item.id}`} className="block p-2">
                <h1 className="text-[16px] font-bold">{item.title}</h1>
                <h3 className="text-[14px] mt-2">{item.auth}</h3>
              </Link>
            </div>
          )
        })}
      </div>
    </div>
  )
}
```
![](./img/7.png)
我们可以看到返回的html，已经是后端渲染好的了。next13默认ssr服务端渲染      
控制台我们能看到
![](./img/8.png)
fetch是支持缓存的。这个我们来看看
